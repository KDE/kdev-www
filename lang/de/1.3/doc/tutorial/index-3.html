<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE>KDE Anwendungs Tutorials: Das Erstellen der QT Tutorials</TITLE>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="keywords" CONTENT="">
<META NAME="description" CONTENT="">
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#aa0000" TEXT="#000000" > 
<FONT FACE="Helvetica">
<A HREF="http://www.kde.org/"><IMG SRC="logotp3.png" BORDER="0" ALT="The K Desktop Environment"></A>
<HR WIDTH="100%" SIZE=2 ALIGN="CENTER" NOSHADE>

 
<P ALIGN="RIGHT">

<A HREF="index-4.html">Weiter</A>
 <A HREF="index-2.html">Zurück</A>
 <A HREF="index.html#toc3">Inhaltsverzeichnis</A>
</P>
<H3><A NAME="s3">3. Das Erstellen der QT Tutorials</A></H3>

<P> 
<P>
<H3><A NAME="ss3.1">3.1 Schritt 1: Hallo Welt!</A>
</H3>

<P>
<P>Wie im vorangehenden Kapitel erläutert, haben wir bereits 
ein Projekt mit dem Namen <CODE>MyWidget</CODE> erstellt. Wenn Sie 
nun die erste Seite des QT Tutorials betrachten, werden Sie 
feststellen, daß die erste Anwendung nur die Funktion <CODE>main()</CODE> 
verwendet. Darum müssen wir jetzt nur die vorgegebene <CODE>main()</CODE>
Funktion unseres Projektes ändern, um das erste Beispiel 
des Tutorials zum Laufen zu bringen.
<P>Um in den Quelltext der Funktion <CODE>main()</CODE> 
zu springen, gehen Sie mit der Maus in den Ordner "Globale", 
und von dort in den Unterordner "Funktionen", der alle 
globalen Funktionen enthält, die keiner Klasse angehören. 
Durch Anklicken des Eintrages von <CODE>main()</CODE> öffnet sich 
die Datei <CODE>main.cpp</CODE> im Fenster "C/C++ Dateien", und der 
Cursor steht am Anfang der ersten Zeile von <CODE>main()</CODE>.     
<P>
<H4>Die erste Änderung</H4>

<P>
<P>Wir könnten nun damit beginnen, den vorhandenen Code so zu 
ändern, daß er dem im Tutorial aufgeführten entspricht. Aber 
das geht auch einfacher. Markieren Sie den Inhalt von 
<CODE>main()</CODE> mit der Maus oder durch Festhalten der 
"Shift"-Taste, während Sie die Zeilen mit der 
Pfeil-nach-unten Taste markieren. Wählen Sie nun 
"Ausschneiden" aus dem Menü "Bearbeiten" oder betätigen Sie 
die "Entf"-Taste, um den markierten Code zu entfernen. 
Dadurch erhalten wir eine leere main Funktion, und wir 
können ganz von vorn beginnen, um unser erstes Tutorial zu 
erstellen.
<P>Fügen Sie nun den Code aus dem Beispiel ein. Dazu könnten 
Sie zunächst das Beispiel sorgfältig studieren und sich 
danach merken, welche Zeile welchen Code enthält. 
Nachdem Sie dann die zeilenweise Beschreibung des Tutorials
gelesen haben, könnten Sie diese als Anleitung verwenden, um
den Code selbst zu schreiben.
<P>Nun, wer den einfachen Weg gehen möchte, markiert den Inhalt 
der <CODE>main.()</CODE> Funktion im Dokumentationsbrowser und 
klickt auf das Icon zum Kopieren in der Werkzeugleiste. 
Alternativ können Sie hierzu auch das Kontextmenü oder den 
entsprechenden Eintrag aus dem Menü "Bearbeiten" benutzen. 
Hierdurch wird die Markierung in die Zwischenablage kopiert 
und kann, nachdem wir ins Quelltext Fenster zurückgekehrt 
sind, über "Einfügen" (entweder aus dem Kontextmenü, der 
Werkzeugleiste oder dem entsprechenden Eintrag im Menü 
"Bearbeiten") in unsere <CODE>main.()</CODE> Funktion eingefügt 
werden. 
<P>Abschließend fügen Sie die Einträge zum Einbinden der 
entsprechenden Headerdateien außerhalb (und vor!)der 
<CODE>main()</CODE> Funktion hinzu.  
<P>
<BLOCKQUOTE><CODE>
<PRE>
 
#include &lt;qapplication.h>
#include &lt;qpushbutton.h> 
</PRE>
</CODE></BLOCKQUOTE>
 
<P>Das war's. Da haben Sie den Quellcode für Ihre erste 
Tutorial Anwendung!
<P>
<H4>Wir übersetzen Hello World!</H4>

<P> 
<P>Um das erste Tutorial zu übersetzen, wählen Sie im Menü 
"Erstellen" den Punkt "Erstellen", oder klicken Sie auf das 
entsprechende Icon in der Werkzeugleiste. Genausogut können 
Sie "Ausführen" nehmen, was dazu führt, daß die Anwendung 
nach dem Erstellen gestartet wird. Tritt während des 
Erstellens ein Fehler auf, können Sie davon ausgehen, daß 
der Fehler beim Programmierer liegt, nicht beim Tutorial! Es 
wäre zwar traurig, wenn Sie jetzt schon nach einem Fehler 
suchen müssen, wo Sie doch gerade erst anfangen KDE und/oder 
QT zu programmieren, aber nutzen Sie diese Gelegenheit 
einfach dazu, sich im Umgang mit KDevelop zu üben. 
<P>Jetzt gibt es für Sie zwei Möglichkeiten, einen Fehler zu 
finden: Entweder Sie gehen auf die entsprechende Zeile in 
der Ausgabeansicht, oder Sie drücken F4. Beides führt 
dazu, daß im Quelltext die Zeile angesprungen wird, in der der Fehler 
auftrat. Das selbe Ziel erreichen Sie im Menü "Ansicht", indem Sie 
dort den Menüpunkt "Nächster Fehler" auswählen.  
<P>
<H4>Übungen</H4>

<P>
<P>Übungen? Was soll das? werden Sie sich fragen. Das war so 
einfach, ich brauche keine Übungen. Aber seien Sie gewiß, 
es wird noch komplizierter. Das vorangegangene Beispiel war 
das leichteste, aber mit wachsender Komplexität wird von 
Ihnen mehr Mitdenken gefordert werden, damit Sie den
weiteren Schritten des Tutorials folgen können und die 
Beispiele verstehen. 
<P>Darüberhinaus lernen Sie durch diese Übungen, wie 
man KDevelop und seine Möglichkeiten einsetzt. Um noch ein 
wenig mehr aus dem ersten Tutorial zu lernen, sollten Sie 
einmal versuchen, am bestehenden Code die nachstehenden
Änderungen vorzunehmen. Finden Sie heraus, welchen Einfluß 
diese Änderungen auf das Verhalten der Anwendung haben.
<P>
<OL>
<LI>Ändern Sie den Pushbutton in ein QLabel. 
</LI>
<LI>Verzichten Sie auf das direkte Setzen des Textes für 
den Pushbutton im Konstruktor, und verwenden Sie stattdessen 
<CODE>setText()</CODE>.
</LI>
<LI>Verwenden Sie <CODE>QPushButton::resize ( const QSize &amp; s )</CODE>
anstelle des direkten Setzens von Höhe und Breite. Legen Sie 
dazu zunächst eine Instanz von <CODE>QSize</CODE> mit der 
gewünschten Größe an. 
</LI>
<LI>Spielen Sie mit den Größen herum, um zu sehen, welche 
Höhe oder Breite beeinflußt.</LI>
</OL>
 
<P>
<H3><A NAME="ss3.2">3.2 Schritt 2 und 3: Erweiterungen</A>
</H3>

<P> 
<P>Die Schritte 2 und 3 des Tutorials erweitern das erste 
Tutorial. Sie lernen darin etwas über signals und slots und 
über die Eltern-Kind Beziehungen zwischen Widgets. Aber 
warum ist es eigentlich so wichtig, etwas darüber zu lernen?
Nun ja, signals und slots verkörpern die Technologie, die 
den Unterschied zwischen der QT und anderen Widget 
Bibliotheken ausmacht. Jedes Mal, wenn sie auf ein 
Implementierungsproblem stoßen, bei dem zwei Objekte 
miteinander kommunizieren sollen, vereinfacht dieser 
Mechanismus die Sache ungemein, und es passiert nichts 
schlimmes, wenn einmal etwas schiefgeht. Selbst Fehler beim 
Verbinden der Objekte führen nicht zu einem Absturz. Darin 
liegt die Stärke der QT Bibliothek, und eine Menge KDE/QT 
Entwickler würden sie aufgrund ihrer Flexibilität nicht mehr 
missen wollen. 
<P>Das Verständnis des signal/slot Mechanismus ist wesentlich 
für die Erstellung jeder KDE/QT Anwendung. 
<P>Beachten Sie auch, daß der Button die Instanz von <CODE>QApplication</CODE> 
durch Aufruf von <CODE>quit()</CODE> beendet. Dieses <CODE>quit()</CODE> 
begegnet Ihnen wieder, wenn wir uns mit dem KDE Pendant von 
<CODE>QApplication</CODE>, der Klasse <CODE>KApplication</CODE> 
beschäftigen.
<P>
<P>
<H3><A NAME="ss3.3">3.3 Schreiben Sie Ihre eigenen Widgets</A>
</H3>

<P>
<P>Nachdem Sie nun die <CODE>main()</CODE> Funktion erfolgreich 
verändert und erweitert haben, sind wir an dem Punkt 
angelangt, an dem Sie ein neues Widget erstellen. Ein 
einzigartiges Widget, das nur mit der Klasse erzeugt werden 
kann, die Sie in diesem Schritt erstellen werden.
<P>Eigentlich hat der Application Wizard den Code hierfür 
bereits für Sie erzeugt, so daß es nicht mehr viel zu tun 
gibt. Sie müssen nur noch den Code, den Übung 4 der Datei 
<CODE>main.cpp</CODE> hinzufügt, in die Headerdatei und die 
Implementierungsdatei der Klasse <CODE>MyWidget</CODE> eintragen. 
<P>Glücklicherweise müssen Sie die Implementierung nur noch dem 
Konstruktor von <CODE>MyWidget</CODE> hinzufügen. Zum Konstruktor 
gelangen wir durch Anwählen des Eintrages im 
Klassenbrowser. Damit springen wir automatisch direkt zur 
Implementierung im Quelltext, zu der Stelle also, wo Sie den 
Code einfügen müssen. Sie müssen sich nur noch um das 
Einbinden von <CODE>qfont.h</CODE> kümmern. <CODE>QFont</CODE> wird 
ausschließlich im Konstruktor von <CODE>MyWidget</CODE> benutzt. 
Darum fügen wir die Zeile <CODE>#include &lt;qfont.h&gt;</CODE> am 
Anfang von <CODE>mywidget.cpp</CODE> ein. 
<P>Zum Starten der Anwendung, gehen Sie einfach auf 
"Ausführen". Das führt zunächst nach einem automatischen 
Speichern zum Übersetzen Ihrer Änderungen.
<P>
<H3><A NAME="ss3.4">3.4 Wir Erweitern die Widget Klasse</A>
</H3>

<P>
<P>Übung 5 hat das Ziel, die Widget Klasse zu erweitern. Darum 
lernen Sie hier auch etwas über virtuelle Funktionen. In 
unserem Fall werden wir die Funktion <CODE>resizeEvent()</CODE> neu 
schreiben. Abgesehen vom Erweitern unserer Klassen, ist es 
wichtig zu wissen, daß QT benutzerdefinierte Ereignisse über 
virtuelle Funktionen abarbeitet, die ein Ereignisobjekt als 
Parameter übergeben bekommen.
<P>Darum sollten Sie sich mit den folgenden Klassen der QT 
Bibliothek vertraut machen:
<P>
<UL>
<LI>QEvent </LI>
<LI>QChildEvent</LI>
<LI>QCloseEvent</LI>
<LI>QFocusEvent </LI>
<LI>QKeyEvent</LI>
<LI>QMouseEvent</LI>
<LI>QMoveEvent </LI>
<LI>QPaintEvent</LI>
<LI>QResizeEvent</LI>
<LI>QTimerEvent </LI>
</UL>
 
<P>Jedesmal, wenn Sie ein eigenes Widget schreiben, 
insbesondere dann, wenn damit sichtbare Teile der Anwendung 
dargestellt werden, müssen Sie die Standard Implementierung 
der Event-Methoden des Widgets durch eigene 
Methoden überschreiben, die bestimmte Ereignisse abarbeiten 
sollen.
<P>Dazu gehört beispielsweise <CODE>virtual void mousePressEvent ( QMouseEvent * )</CODE>, die für die Verarbeitung der 
Maus-Ereignisse zuständig ist, die ein Kontextmenü 
aufklappen lassen. 
<P>Bei der Implementierung müssen Sie im Funktionskopf einen 
formalen Parameter angeben. Die meisten Entwickler vergeben
für den Parameter den Namen <CODE>event</CODE> oder einfach <CODE>e</CODE>. 
Nun können Sie die Parameter des Ereignisses abfragen. Bei 
einem <CODE>QMouseEvent</CODE> müssen Sie feststellen, ob das 
Ereignis durch die rechte, die mittlere oder die linke
Maustaste ausgelöst wurde.
<P>
<H3><A NAME="ss3.5">3.5 Wir fügen eine neue Klasse hinzu</A>
</H3>

<P> 
<P>In Übung 6 werden Sie der Tutorial Anwendung eine neue 
Klasse hinzufügen müssen. Normalerweise würden Sie jetzt 
denken: "Ich muß bloß eine Headerdatei und die 
Implementierungsdatei anlegen, dann bin ich fertig", aber 
KDevelop macht Ihnen die Sache noch einfacher.
<P>Wenn Sie eine neue Klasse anlegen, sollten Sie dazu immer 
den Klassengenerator benutzen. Das nimmt Ihnen die ganze 
Arbeit ab, und Sie müssen der so angelegten Klasse nur noch 
den spezifischen Code hinzufügen. Um mit dem 
Klassengenerator eine neue Klasse anzulegen, wählen Sie im 
Menü "Projekt" den Menüpunkt "Neue Klasse...". Daraufhin 
öffnet sich ein Dialog, in dem Sie alle notwendigen 
Informationen zum Erstellen der Klasse eingeben.
<P>Zunächst müssen wir den Namen der Klasse angeben. Das 
Tutorial verwendet den Namen <CODE>LCDRange</CODE>, also geben wir 
diesen ein.
<P>Nun fahren wir mit der Basisklasse fort. Die Basisklasse ist 
diejenige Klasse, von der unsere Klasse abgeleitet wird. 
Wenn wir im Tutorial (QT 1.42)nachsehen, erfahren wir, es 
handelt sich um <CODE>QWidget</CODE>. Weil fast alle benötigten GUI 
Klassen von <CODE>QWidget</CODE> abgeleitet werden, macht uns der 
Klassengenerator die Angelegenheit noch leichter. 
<P>Wir lassen das Feld für die Basisklasse leer und markieren unter 
"Zusätzliche Optionen" die Checkbox "QWidget-Childklasse 
erzeugen". Dadurch wird in der Headerdatei der Klasse 
automatisch das <CODE>Q_OBJECT</CODE> Makro eingetragen, das für die 
später (in Kapitel 7) benötigten slots und signals unbedingt 
notwendig ist. Da die Dateinamen bereits automatisch 
eingetragen werden, müssen Sie sich darum nicht mehr 
kümmern. 
<P>Allerdings empfehlen wir Ihnen, das Feld Dokumentation 
auszufüllen. Es zählt zum guten Stil, der Klasse eine 
beschreibende Dokumentation mit auf den Weg zu geben, 
insbesondere wenn der Name der Klasse, hier <CODE>LCDRange</CODE>, 
keine genauere Auskunft über den Verwendungszweck des 
Widgets gibt.            
<P>
<H3><A NAME="ss3.6">3.6 Übung 7-14</A>
</H3>

<P>
<P>Sie sind nun für die restlichen Schritte des Tutorials 
gerüstet und wissen alles, was sie wissen müssen, um die 
benötigten Klasse zu erstellen und Änderungen daran 
vorzunehmen. Nach jeder Änderung sollten Sie die Anwendung
mit "Erstellen" übersetzen und Ihren Code auf Fehler 
untersuchen. Starten Sie die Anwendung, und verfolgen Sie 
deren Ausführung. Außerdem sollten Sie mit den "Erstellen" 
Optionen von KDevelop herumspielen; führen Sie die Anwendung 
mit einer Kommandozeilenoption aus, beispielsweise 
--geometry, und debuggen Sie das Programm mit KDbg aus 
dem "Werkzeuge"-Menü oder dem internen Debugger von 
KDevelop. 
<P>Danach sollten Sie in der Lage sein, mit den QT Beispielen
fortzufahren, die mit QT geliefert werden.
Im nächsten Kapitel werden Sie mit Hilfe der Beispielanwendung <EM>KScribble</EM> an die Entwicklung für KDE 2 herangeführt. KScribble ist eine kleine 
Zeichenanwendung, an der Ihnen die Konzepte des Anwendungsdesigns gezeigt 
werden, und an der Sie sehen, wie Sie Ihr Programm implementieren. 
<P ALIGN="RIGHT">

<A HREF="index-4.html">Weiter</A>
 <A HREF="index-2.html">Zurück</A>
 <A HREF="index.html#toc3">Inhaltsverzeichnis</A>
</P>
<CENTER>
<HR WIDTH="100%" SIZE=3 ALIGN=CENTER NOSHADE>
</CENTER>    
</FONT>

 
</BODY>
</HTML>
