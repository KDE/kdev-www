<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE>KDE Anwendungs Tutorials: Erweiterung der GUI</TITLE>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="keywords" CONTENT="">
<META NAME="description" CONTENT="">
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#aa0000" TEXT="#000000" > 
<FONT FACE="Helvetica">
<A HREF="http://www.kde.org/"><IMG SRC="logotp3.png" BORDER="0" ALT="The K Desktop Environment"></A>
<HR WIDTH="100%" SIZE=2 ALIGN="CENTER" NOSHADE>

 
<P ALIGN="RIGHT">

<A HREF="index-11.html">Weiter</A>
 <A HREF="index-9.html">Zurück</A>
 <A HREF="index.html#toc10">Inhaltsverzeichnis</A>
</P>
<H3><A NAME="s10">10. Erweiterung der GUI</A></H3>

<P>Wie wir gesehen haben, haben wir <EM>KScribble</EM> bereits die Fähigkeit gegeben, Bilder mit der Dokumentklasse zu öffnen und zu 
speichern, haben durch Überladen virtueller Methoden Interaktion ermöglicht, und wir haben die erste Funktionalität erreicht- wir 
können auch Bilder zeichnen. Aber als wir die <CODE>QPen</CODE> Instanz erzeugt haben, haben wir vordefinierte Werte für den Stift 
verwendet; die Farbe ist Schwarz und die Breite ist auf 3 Pixel eingestellt. Da Sie für gewöhnlich diese Werte ändern können 
wollen, müssen wir die Haupt-GUI um Funktionen, diese Werte zu setzen, erweitern, je nachdem welches Fenster gerade aktiv ist und 
welches Dokument damit verbunden ist. Dieses Kapitel wird Ihnen daher zeigen:
<P>
<UL>
<LI>Das Hinzufügen eines neuen Menüs zur Menüleiste</LI>
<LI>Erweiterung der Werkzeugleiste um Icons, für die in der Menüleiste definierten Methoden</LI>
<LI>Die Erstellung eines neuen Dialoges mit dem KDevelop Dialogeditor</LI>
<LI>Verbinden der neuen Kommandos der Menü- und Werkzeugleiste mit Aufrufen der Dialoge</LI>
<LI>Ermöglichen der Änderung der Stiftgröße in der Dokumentklasse</LI>
</UL>
<P>Desweiteren fügen wir eine Methode hinzu, den Inhalt des gesamten Dokuments über das Menü zu löschen.
<P>
<H3><A NAME="ss10.1">10.1 Hinzufügen des "Stift" Menüs</A>
</H3>

<P>
<P>Wie der Name dieses Abschnittes schon sagt, werden wir hier ein Menü zum Setzen der Stiftwerte des Dokuments hinzufügen. Menüs, 
die in die Menüleiste eingefügt werden, sind Instanzen von <CODE>QPopupMenu</CODE>, und Sie können einen Blick darauf werfen, wie die 
aktuelle Menüleiste aufgebaut ist, wenn Sie zur <CODE>KScribbleApp</CODE> Klasse, Methode 
<CODE>initMenubar()</CODE> wechseln. Sie werden sehen, daß die Menüleistenelemente in der 
Reihenfolge ihres Erscheinens auf der Menüleiste erzeugt wurden, aber das ist nicht 
notwendigerweise so. Es gibt zwei Dinge, die für das Aussehen der Menüleiste wichtig sind: 
<UL>
<LI>In den Menüs, die Reihenfolge der Einträge</LI>
<LI>In der Menüleiste, die Reihenfolge der Popupmenüs</LI>
</UL>
<P>Schließlich und endlich werden wir zuerst die Menüs erzeugen müssen, indem wir den Konstruktor aufrufen. Die Klassendeklaration 
enthält bereits die Zeiger auf die Popupmenüs, also werden wir zuerst das "Stift" Menü hier einfügen:
<P>
<HR>
<PRE>
kscribbleapp.h

class KScribbleApp
{
.
.
  private:
    QPopupMenu* pPenMenu;

}
</PRE>
<HR>
<P>Jetzt werden wir das Menü selbst erzeugen. Ändern Sie die Implementation der Methode <CODE>KScribbleApp::initMenuBar()</CODE> und 
editieren Sie die, mit dem Pfeil markierten Zeilen:
<P>
<HR>
<PRE>
void KScribbleApp::initMenuBar()
{
..

->  ///////////////////////////////////////////////////////////////////
->  // menuBar entry pen-Menu
->  pPenMenu = new QPopupMenu();
->  pPenMenu->insertItem(i18n("&amp;Color"), ID_PEN_COLOR);
->  pPenMenu->insertItem(i18n("&amp;Brush"), ID_PEN_BRUSH);

    menuBar()->insertItem(i18n("&amp;Edit"), pEditMenu);
->  menuBar()->insertItem(i18n("&amp;Pen"), pPenMenu);
    menuBar()->insertItem(i18n("&amp;View"), pViewMenu);


->  connect(pPenMenu, SIGNAL(activated(int)), SLOT(commandCallback(int)));
->  connect(pPenMenu, SIGNAL(highlighted(int)), SLOT(statusCallback(int)));
}
</PRE>
<HR>
<P>Sie sehen, daß wir zunächst das Menü mit <CODE>new QPopupMenu()</CODE> erzeugen. Dann verwenden wir 
die insertItem Methode, zum Hinzufügen der Menüeinträge Color und Brush. Die sichtbaren 
Kommandos werden mit der Methode <CODE>i18n()</CODE> eingefügt, womit sichergestellt ist, daß Sie 
Ihre Applikation internationalisieren können. Als generelle Regel kann gesagt werden, daß Sie 
alle später sichtbaren Texte mit der Methode <CODE>i18n()</CODE> deklarieren sollten. Nur-Qt Programme, die 
Qt > 2.0 verwenden, benutzen dazu die Methode <CODE>tr()</CODE>, da Qt eigene Verfahren hat, 
Anwendungen zu internationalisieren. Das zweite Argument ist ein Makro, die ID des 
Menüeintrages. Diese ID ist eine Nummer, die wir mit #define in der resource.h, in der Sie 
auch die anderen bisher definierten ID's finden, setzen müssen. Es gibt auch den Weg, Menüs 
direkt einzufügen, indem Sie einen Slot mit dem gewählten Eintrag verbinden, aber das Framework 
dieser Anwendung verwendet ID's, um festzustellen, welche Aktion ausgewählt und markiert wurde. 
Deshalb muß jeder Menüeintrag, unbhängig davon, in welchem Popupmenü er erscheint, eine 
einzigartige Nummer besitzen, und da wir uns Nummern schlecht merken können, ist die Verwendung 
eines #define für die ID eine gute Lösung. Das Popupmenü wird nun ebenfalls mit 
<CODE>insertItem()</CODE> der Menüleiste hinzugefügt, und zwar mit einem Zeiger auf das Menü als 
zweitem Argument. Beachten Sie, daß wir das Popupmenü <EM>nach</EM> dem Edit- und <EM>vor</EM> dem Viewmenü 
eingefügt haben, es wird also später zwischen diesen beiden Menüs erscheinen. Was auch wichtig 
bei der Erstellung von Menüs ist, ist, daß sie dem Benutzer auch über Shortcuts zur Verfügung 
gestellt werden sollten; normalerweise sehen Sie in Menüs einen unterstrichenen Buchstaben, der 
zusammen mit ALT die entsprechende Funktion aufruft. Als Programmierer, müssen Sie diesen 
Buchstaben durch ein vorangestelltes "&amp;" setzen, das "Pen" Menü wird also später durch 
drücken von ALT+P erreichbar sein. Innerhalb des Menüs kann der Benutzer auch <EM>nur</EM> den 
Buchstaben eingeben, um den entsprechen Menüpunkt auszuführen, Sie sollten also für die anderen 
Menüpunkte ebenfalls Tastaturkürzel zur Verfügung stellen. Achten Sie darauf, den Code zum 
Einfügen von Einträgen in Gruppen zusammenzuschreiben, die Sie überblicken können, damit Sie 
keine Kürzel doppelt verwenden (Dies ist auch für Ihre Übersetzer wichtig: In anderen Sprachen 
kommt das gewählte Kürzel vielleicht nicht im Menütext vor, der Übersetzer muß also auch wieder 
ein Kürzel auswählen). 
<P>In den letzten beiden Zeilen verbinden wir die Stiftmenüs mit zwei Slots: einen für das 
Menüsignal "aktiviert, Aktion ausführen" und einen für die Markierung des Menüeintrages. Dies 
ermöglicht es, eine Hilfemeldung in der Stauszeile anzuzeigen. Sie können sich die Methoden 
ansehen, die mit dem Menü verbunden sind. Sie enthalten Anweisungen, in denen die gesendete ID 
geprüft und die folgende Aktion aufgerufen wird. Was noch zu tun bleibt, ist die #define 
Anweisungen in die resource.h einzutragen:     
<P>
<HR>
<PRE>
 
resource.h ///////////////////////////////////////////////////////////////////
// Pen-menu entries
#define ID_PEN_COLOR                14010
#define ID_PEN_BRUSH                14020
</PRE>
<HR>
<P>Sie sehen, daß die Nummern für jeden Eintrag einzigartig sind. Sie müssen darauf achten, 
nicht zweimal dieselbe Nummer zu vergeben. Sollte es aber dennoch einmal versehentlich 
passieren, wird Sie der Compiler über die Redefinition informieren.
<P>Das ist zum jetzigen Zeitpunkt alles, das Sie zum Hinzufügen eines neuen Menüs tun müssen. Die 
ausgeführten Aktionen sind: "Color" (Aufruf des Farbauswahldialogs) und "Brush" (Aufruf des Dialogs 
zum Setzen der Stiftbreite). Letzeren Dialog werden wir noch erstellen, aber zuerst werden wir im 
nächsten Kapitel auch die Werkzeugleiste um zwei Icons für diese Aktionen erweitern.
<P>
<P>
<H3><A NAME="ss10.2">10.2 Hinzufügen von Knöpfen zur Werkzeugleiste</A>
</H3>

<P>
<P>Wenn Sie neue Kommandos über Knöpfe in der Werkzeugleiste zur Verfügung stellen möchten, können 
Sie dies leicht mit der <CODE>initToolbar()</CODE> Methode der <CODE>App</CODE> Klasse tun. Hier 
entscheiden wir uns, je einen Knopf für die beiden Menüeinträge im Stiftmenü hinzuzufügen, aber 
diese Knöpfe brauchen Icons. Sie können sie entweder im KDE Verzeichnis "toolbar" finden, oder, 
wenn keins der Icons zu der Aktion paßt, sie selbst erzeugen. KIconEdit ist gut dafür geeignet 
Icons zu erstellen, also werden wir sie zuerst erzeugen. Wählen Sie "Neu" aus dem KDevelop 
Dateimenü, gehen Sie auf den Linux/KDE Tabulator und wählen Sie dann "Icon" als Dateityp. Das 
erste Icon nennen wir "pencolor.xpm". Nun müssen wir sagen, wo das Icon erzeugt werden soll. 
Drücken Sie den Verzeichnisauswahlknopf und wechseln Sie in das Verzeichnis mit Ihren 
<EM>KScribble</EM> Quelldateien. Dort erzeugen Sie ein neues Verzeichnis "toolbar". Wechseln Sie in 
dieses Verzeichnis und drücken Sie "OK". Das neue Icon wird erzeugt und automatisch mit 
KIconEdit innerhalb von KDevelop geöffnet. Zeichnen Sie etwas, daß dem Benutzer den Sinn des 
Knopfes zeigt, speichern Sie das Pixmap und wählen Sie dann den LFV / RFV in KDevelop. Wählen 
Sie das Icon mit der rechten Maustaste aus und gehen Sie im Popupmenü auf "Eigenschaften". Sie 
sehen, daß das Icon der Distribution hinzugefügt wurde, damit es aber später von Ihrem Programm 
gefunden werden kann, müssen Sie das Installationsziel ebenfalls angeben. Markieren Sie die "installieren" Option und geben 
Sie dann darunter ein:
<P><CODE>$(kde_datadir)/kscribble/toolbar/pencolor.xpm</CODE>
<P>Damit wird das Pixmap im data Verzeichnis der KDE Dateisystemhierarchie installiert, in der 
jede Anwendung ihr Unterverzeichnis mit zusätzlich benötigten Dateien hat. Icons müssen in 
einem Unterverzeichnis namens toolbar abgelegt werden, damit der icon loader die Pixmaps für 
Ihr Programm finden kann. 
<P>Wenn Sie damit fertig sind, wiederholen Sie die gleichen Schritte für das Icon zum 
Setzen der Stiftweite. Nennen Sie dieses Icon "penwidth.xpm".
<P>Nun müssen wir nur noch Knöpfe auf der Werkzeugleiste erzeugen; fügen Sie dazu die markierten 
Zeilen Ihrem Code hinzu: 
<P>
<HR>
<PRE>
void KScribbleApp::initToolBar()
{
..
    toolBar()->insertButton(BarIcon("editcopy"), ID_EDIT_COPY, true, i18n("Copy"));
    toolBar()->insertButton(BarIcon("editpaste"), ID_EDIT_PASTE, true, i18n("Paste"));
    toolBar()->insertSeparator();
->  toolBar()->insertButton(BarIcon("pencolor"), ID_PEN_COLOR, true, i18n("Color") );
->  toolBar()->insertButton(BarIcon("penwidth"), ID_PEN_BRUSH, true, i18n("Width") );
->  toolBar()->insertSeparator();
    toolBar()->insertButton(BarIcon("help"), ID_HELP_CONTENTS, SIGNAL(clicked()),
..
}
</PRE>
<HR>
<P>Wir verwenden an dieser Stelle die Methoden von KToolBar um die Knöpfe einzufügen. Das erste 
Argument, <CODE>BarIcon()</CODE>, veranlaßt die Methode, das Icon für den Knopf zu laden. Was etwas 
ungewöhnlich erscheint ist, daß wir uns nicht um die Dateierweiterung zu kümmern brauchen. Das 
bevorzugte Format unter KDE 2 ist *.PNG, aber es funktioniert auch mit xpm's ( Sie könnten 
ImageMagick für die Konvertierung der Icons nach PNG verwenden, oder, zu einem späteren 
Zeitpunkt,<EM>KScribble</EM> !). 
<P>Das zweite Argument ist wiederum die ID. Die Kommandos werden dann automatisch aktiviert, da 
<CODE>toolBar()</CODE> bereits mit denselben Methoden verbunden ist wie die Menübar, über das Signal 
<CODE>activated()</CODE>. Das dritte Argument steht für "erreichbar" wenn wahr, "deaktiviert" wenn 
falsch; da die Knöpfe verfügbar sein sollen, setzen wir es auf wahr. Schließlich setzen wir 
noch eine Kurzinfo für die Knöpfe, die wir wieder in <CODE>i18n()</CODE> einschließen, um die 
Internationalisierung zu ermöglichen. 
<P>Nun sind Sie für's erste fertig. Die GUI ist, zumindest visuell, erweitert. Sie können 
<EM>KScribble</EM> wieder kompilieren und ausführen und sich anschauen, wie es aussieht- natürlich haben 
die neuen Elemente in der Menü- und in der Werkzeugleiste noch keine Funktion- dies wird sich aber 
im nächsten Abschnitt ändern. Sie werden vielleicht auch bemerken, daß die Icons, die wir 
hinzugefügt haben, nicht angezeigt werden. Dies liegt daran, daß wir <EM>KScribble</EM> nicht 
installiert haben, und so werden sie nicht gefunden. Alle anderen Icons werden bereits mit den KDE 
Bibliotheken geliefert, deshalb sind sie schon sichtbar.
<P>
<H3><A NAME="ss10.3">10.3 Erzeugen des Dialogs für die Stiftweite</A>
</H3>

<P>Da wir schon die Menüleisten- und Werkzeugleistenkommandos erstellt haben, müssen wir jetzt unseren 
ersten Dialog für das Setzen der Stiftweite erzeugen. Dazu wählen Sie "Neu" aus dem Dateimenü und 
dann "Qt/KDE Dialog". Geben Sie als Dialognamen <CODE>kpenbrushdlg</CODE> ein, die Erweiterung wird 
automatisch angehängt. Wählen Sie "OK" und der Dialogeditor öffnet ein leeres Widget, das den 
Hintergrund für unseren Dialog bilden wird. Wenn wir einen Dialog entwerfen, müssen wir uns 
überlegen, was der Benutzer wirklich braucht; in unserem Fall brauchen wir ein Label, das 
beschreibt, was geändert wird, eine Spinbox mit auf und ab Knöpfen zum Setzen der Stiftweite und 
drei weitere Knöpfe: einen zum Zurücksetzen der Weite, einen zum Abbrechen des Dialogs und einen zum 
Übernehmen des neuen Wertes - den "OK" Knopf. In dieser Reihenfolge werden wir die Elemente auch 
hinzufügen, was wichtig ist, weil der Fokus der Tabulatortaste der Reihenfolge folgt, in der die 
Widgets erstellt werden. D.h., wenn Sie mit dem "OK" Knopf anfangen, bringt uns das Drücken der 
Tabtaste zuerst zur Spinbox und dann zum "Cancel" Knopf - was so nicht erwartet wird. Der Tabfokus 
sollte den Elementen von oben nach unten und von links nach rechts folgen, also müssen wir den 
Dialog auch in dieser Reihenfolge erstellen. Um Elemente zum Dialog hinzuzufügen, wählen Sie den 
Widgets Tabulator im linken Panel. Dort werden alle verfügbaren Widgets durch Icons repräsentiert, 
damit Sie Ihren Dialog erstellen können. Ein Druck auf ein Widget Icon erzeugt das neue Element in 
der linken, oberen Ecke des Hauptwidgets. Von dort können Sie es mit der Maus zu der Position 
ziehen, an der Sie das Element haben wollen. Desweiteren können Sie die Einstellungen für das 
gewählte Widget im "Widgeteigenschaften" Panel auf der rechten Bilschirmseite vornehmen.
<P><B>Das Label:</B> Wählen Sie <CODE>QLabel</CODE> aus dem Widgettabulator und plazieren Sie es an 
Position x:50, y:20. Dann gehen Sie zum "General" Abschnitt in den Widgeteigenschaften. Ändern Sie den Text der Eigenschaft "Text" 
von "Label:" nach "Pen Width:". Passen Sie die Breite in x-Richtung dem Text des Labels an, ein Wert von 120 sollte reichen. 
Sie können dies entweder mit der Maus machen, oder den Wert im "Geometry" Abschnitt eingeben.
<P><B>Die Spinbox:</B> Wählen Sie <CODE>QSpinbox</CODE> und plazieren Sie sie rechts neben dem eben 
erstellten Label. Setzen Sie den Variablennamen im Abschnitt "C++ Code" auf "width_spbox". Die 
Minimal- und Maximalwerte sind 1 und 100, was für unsere Stiftweite ausreichen sollte.
<P><B>Die Knöpfe:</B> Schließlich brauchen wir noch unsere drei Knöpfe. Der linke Knopf soll der 
Standardknopf sein. Erzeugen Sie einen <CODE>QPushbutton</CODE> und plazieren Sie ihn an einer günstigen 
Stelle unten im Dialog, setzen Sie den Variablennamen auf "default_btn" und den Text auf "Default". 
Machen Sie das gleiche mit dem "OK" Knopf, Variablenname "ok_btn" und dem "Cancel" Knopf, 
Variablenname "cancel_btn". Setzen Sie die Knopftexte auf "&amp;OK" und "&amp;Cancel".
<P>Wenn Sie mit Ihrem Layout zufrieden sind, wählen Sie "Alle Quellen erzeugen" aus dem "Erstellen" 
Menü, geben Sie als Klassennamen "KPenBrushDlg" ein und wählen Sie <CODE>QDialog</CODE>. Nachdem Sie 
"OK" gedrückt haben, werden die Quellen für Ihren Dialog erzeugt und dem Projekt hinzugefügt. Sie 
können nun wieder zur Editoransicht in KDevelop zurückkehren und wir können den Code hinzufügen, 
der benötigt wird, damit der Dialog auch etwas macht.
<P>
<H3><A NAME="ss10.4">10.4 Verbinden und Einstellen</A>
</H3>

<P>Nachdem wie nun die GUI des Dialogs erstellt haben, müssen wir den Köpfen noch die Funktionalität 
geben, und Mittel zur Verfügung stellen, die Werte der Spinbox zu holen und zu setzen, weil wir 
wollen, daß der Dialog den aktuellen Wert anzeigt, wenn er aufgerufen wird, und wir möchten den 
eingestellten Wert auslesen, wenn der "OK" Knopf gedrückt wird. 
<P>In der erzeugten Klasse <CODE>KPenBrushDlg</CODE> können Sie neben dem Konstruktor und dem Destruktor 
noch die Methode <CODE>initDialog()</CODE> finden. Diese Methode implementiert die gesamte GUI 
Konstruktion, deshalb müssen wir uns darum nicht mehr kümmern, sondern können direkt die üblichen 
Verbindungen für unsere Knöpfe erstellen. Fügen Sie die markierten Zeilen in den Konstruktor des 
Dialogs ein: 
<P>
<HR>
<PRE>
KPenBrushDlg::KPenBrushDlg(int curr, QWidget *parent, const char *name) : QDialog(parent,name,true){
        initDialog();

->      connect(default_btn, SIGNAL(clicked()), this, SLOT(slotDefault()));
->      connect(ok_btn, SIGNAL(clicked()), this, SLOT(accept()));
->      connect(cancel_btn, SIGNAL(clicked()), this, SLOT(reject()));
}
</PRE>
<HR>
<P>Dies implementiert die Funktionalität für die Knöpfe, für den Fall, daß sie gedrückt werden. Als 
erstes stellen wir den Standardknopf so ein, daß er den Slot <CODE>slotDefault()</CODE> ausführt. Dieser 
Slot, in dem wir den Standardwert für die Spinbox direkt setzen, muß noch implementiert werden. 
<P>Der zweite <CODE>connect()</CODE> Aufruf verbindet den "OK" Knopf mit dem Slot <CODE>accept()</CODE>, der 
von <CODE>QDialog</CODE> bereitgestellt wird, genauso wie der <CODE>reject()</CODE> Slot, den wir mit dem 
"Cancel" Knopf verbinden. "Cancel" wird sowohl den Dialog schließen, als auch den resultierenden 
Wert setzen, den wir später, wenn wir die Methode implementieren, die den Dialog aufruft, dazu 
verwenden werden, herauszufinden ob der neu eingestellte Wert verwendet oder die ganze Aktion 
abgebrochen werden soll.
<P>Jetzt werden wir die beiden Methoden zum Setzen und holen der Spinbox-Werte hinzufügen:
<P>
<HR>
<PRE>
void setCurrent(int curr){ width_spbox->setValue(curr); }
int width() { return width_spbox->value(); };
</PRE>
<HR>
<P>Fügen Sie diese Methoden in der Klassendeklaration mit dem Modifizierer "public" ein, da wir die 
Werte setzen und holen wollen, wenn der Dialog angezeigt wird. Die Methode <CODE>setCurrent()</CODE> wird zum Setzen des 
aktuellen Stiftwertes verwendet, die <CODE>width()</CODE> Methode liefert den Wert zurück, den die 
Spinbox hat, wenn der Benutzer "OK" drückt.
<P>Schließlich müssen wir noch die Methode <CODE>slotDefault()</CODE> implementieren:
<P>
<HR>
<PRE>
//kpenbrushdlg.h:
//method declaration:

public slots:
  void slotDefault();

//kpenbrushdlg.cpp:
//method implementation:

void KPenBrushDlg::slotDefault()
{
  width_spbox->setValue(3);
}
</PRE>
<HR>
<P>Dies setzt den Standardwert für die Stiftbreite auf 3 Pixel.
<P>Wir sind nun mit unserem ersten Dialog fertig und können uns den anderen Klassen der Anwendung 
zuwenden, um noch einiges zu adaptieren und Methoden zu implementieren, die den Dialog aufrufen.
<P>
<P>
<H3><A NAME="ss10.5">10.5 Aufrufen der Dialoge</A>
</H3>

<P>Wie Sie sich vielleicht schon denken können, bedeutet das Aufrufen der Dialoge nicht nur, 
daß wir den Dialog zur Auswahl der Stiftgröße implementieren werden, sondern auch, daß wir 
eine Methode zur Auswahl der Stiftfarbe hinzufügen. Doch eins nach dem anderen. Als erstes 
erzeugen Sie eine Methode <CODE>slotPenBrush()</CODE> in der Klasse <CODE>KScribbleApp</CODE>:
<P>
<HR>
<PRE>
void KScribbleApp::slotPenBrush()
{
  slotStatusMsg(i18n("Setting brush width..."));

  // get one window with document for a current pen width
  QWidgetList windows = pWorkspace->windowList();
  KScribbleView* m = (KScribbleView*)windows.at(0);
        KScribbleDoc* pDoc = m->getDocument();
  int curr_width=pDoc->penWidth();

  // create the dialog, get the new width and set the pen width for all documents
  KPenBrushDlg* dlg= new KPenBrushDlg(this);
  dlg->setCurrent(curr_width);
  if(dlg->exec()){
    int width=dlg->width();
        for ( int i = 0; i &lt; int(windows.count()); ++i )
        {
        m = (KScribbleView*)windows.at(i);
        if ( m )
        {
                pDoc = m->getDocument();
        pDoc->setPenWidth(width);
        }
        }
  }
  slotStatusMsg(i18n("Ready."));
}
</PRE>
<HR>
<P>Hier müssen wir zuerst auf die Fensterliste zugreifen und den Zeiger auf ein Dokument 
holen - das ein Dokument eines beliebigen Fensters sein kann, da alle Dokumente die 
gleiche aktuelle Stiftweite haben sollten. Dann legen wir eine Integervariable curr_width 
an, welche die aktuelle Stiftweite speichert.
<P>Jetzt können wir den Dialog aufrufen, indem wir eine dlg Instanz von KPenBrushDlg 
erzeugen. Dann setzen wir die aktuelle Stiftweite durch einen Aufruf der Methode 
<CODE>dlg->setCurrent()</CODE>, die wir ja dem Dialog hinzugefügt haben. Durch Aufruf von 
<CODE>dlg->exec()</CODE> zeigen wir den Dialog an. Die <CODE>if()</CODE> Anweisung stellt sicher, 
daß der folgende Code nur ausgeführt wird, wenn das Accept Flag gesetzt ist - das 
bedeutet, der Code wird ausgeführt, wenn der Benutzer den "OK" Knopf gedrückt hat. 
<P>Davon ausgehend, daß der Benutzer den Wert geändert und "OK" gedrückt hat, müssen wir in 
allen Dokumenten die neue Stiftweite einstellen. Dazu verwenden wir die <CODE>for()</CODE> 
Schleife und setzen in jedem Dokument die entsprechende Variable, die wir zuvor mit 
<CODE>dlg->width()</CODE> geholt haben. 
<P>Wir haben die Methode <CODE>setPenWidth()</CODE> noch nicht in der Dokumentklasse 
implementiert, also werden wir das jetzt nachholen: 
<P>
<HR>
<PRE>

kscribbledoc.h:

public:
  void setPenWidth( int w ){ pen.setWidth( w ); }
</PRE>
<HR>
<P>Was noch fehlt, damit überhaupt eine Aktion ausgeführt wird, ist die Methoden 
hinzuzufügen, die aufgerufen werden sollen, wenn die Menüpunkte aktiviert oder die Knöpfe 
in der Werkzeugleiste gedrückt werden. Dazu müssen wir die ID's im Slot 
<CODE>commandCallback()</CODE> eintragen, der die entsprechenden Methoden auswählt und 
ausführt:   
<P>
<HR>
<PRE>
void KScribbleApp::commandCallback(int id_)
{
  switch (id_)
  {
    case ID_PEN_BRUSH:
      slotPenBrush();
      break;

    case ID_PEN_COLOR:
      slotPenColor();
      break;
....
  }
}
</PRE>
<HR>
<P>Diese Erweiterung fügt auch die Methode <CODE>slotPenColor()</CODE> zum Setzen der Stiftfarbe 
in die Liste der auszuführenden Methoden ein. Diese Methode werden wir nun implementieren: 
<P>
<HR>
<PRE>
void KScribbleApp::slotPenColor()
{
  slotStatusMsg(i18n("Selecting pen color..."));

  QColor myColor;
  int result = KColorDialog::getColor( myColor, this );
  if ( result == KColorDialog::Accepted )
  {
    QWidgetList windows = pWorkspace->windowList();
    KScribbleDoc* pDoc;
    KScribbleView* m;
    for ( int i = 0; i &lt; int(windows.count()); ++i )
    {
      m = (KScribbleView*)windows.at(i);
      if ( m )
      {
        pDoc = m->getDocument();
        pDoc->setPenColor(myColor);
      }
    }
  }
  slotStatusMsg(i18n("Ready."));
}
</PRE>
<HR>
<P>Wenn wir uns den Code ansehen, erkennen wir, daß wir eine weitere neue Methode von 
<CODE>KScribbleDoc</CODE> verwenden, um die Farbe des Stifts zu setzen. Diese Methode müssen 
wir ebenfalls implementieren: 
<P>
<HR>
<PRE>
kscribbledoc.h:

    /** sets the pen color */
    void setPenColor( const QColor &amp;c ){ pen.setColor( c ); }
</PRE>
<HR>
<P>Denken Sie daran, die Deklarationen für <CODE>slotPenBrush()</CODE> und 
<CODE>slotPenColor()</CODE> auch einzufügen, damit Ihre Klasse <CODE>KScribbleApp</CODE> sie 
überhaupt kennt. 
<P>Nun sind Sie fertig. Lassen Sie uns zusammenfassen, was wir in diesem Kapitel getan haben:
<P>
<UL>
<LI> Zunächst haben wir Menü- und Werkzeugleistenkommandos und -elemente für zwei 
Dialoge, die wir aufrufen wollen, eingefügt.</LI>
<LI> Dann haben wir mit dem Dialogeditor den Dialog zum Einstellen der Stiftweite 
erstellt.</LI>
<LI> Als nächstes haben wir die Methoden geschrieben, die die Dialoge aufrufen und die 
Eigenschaften setzen die wir ändern wollen.</LI>
<LI> Schließlich haben wir die benötigten Set-Methoden hinzugefügt, sodaß wir in der 
Lage sind, die Werte zu ändern, nachdem die Dialoge ausgeführt worden sind.</LI>
</UL>
<P>Mit dieser Struktur steht Ihnen ein allgemeiner Weg zur Verfügung, Ihre Anwendung um 
weitere Funktionalität zu erweitern und Einstellungen zu manipulieren, die das Verhalten 
des Dokumentes und die Interaktion mit den Ansichten beeinflussen.
<P>
<P>
<P ALIGN="RIGHT">

<A HREF="index-11.html">Weiter</A>
 <A HREF="index-9.html">Zurück</A>
 <A HREF="index.html#toc10">Inhaltsverzeichnis</A>
</P>
<CENTER>
<HR WIDTH="100%" SIZE=3 ALIGN=CENTER NOSHADE>
</CENTER>    
</FONT>

 
</BODY>
</HTML>
