<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE>Benutzerhandbuch zu KDevelop: Programme</TITLE>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="keywords" CONTENT="">
<META NAME="description" CONTENT="">
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#aa0000" TEXT="#000000" > 
<FONT FACE="Helvetica">
<A HREF="http://www.kde.org/"><IMG SRC="logotp3.png" BORDER="0" ALT="The K Desktop Environment"></A>
<HR WIDTH="100%" SIZE=2 ALIGN="CENTER" NOSHADE>

 
<P ALIGN="RIGHT">

<A HREF="index-4.html">Weiter</A>
 <A HREF="index-2.html">Zurück</A>
 <A HREF="index.html#toc3">Inhaltsverzeichnis</A>
</P>
<H3><A NAME="Programme"></A> <A NAME="s3">3. Programme</A></H3>

<P>Nachdem KDevelop erfolgreich installiert und die allgemeinen Einstellungen vorgenommen sind, möchten Sie wahrscheinlich wissen, ob die
Entwicklungsumgebung hält, was sie verspricht. Dieses Kapitel gibt Ihnen einen Leitfaden, wie Programme allgemein mit den GNU Werkzeugen erzeugt werden
und welchen Teil speziell KDevelop in diesem Prozeß übernimmt.
<P>
<H3><A NAME="Der Compiler"></A> <A NAME="ss3.1">3.1 Der Compiler</A>
</H3>

<P>Der Compiler ist letztlich das Programm auf Ihrem System, das mindestens installiert sein muß um laufende Programme zu erzeugen; er ist
derjenige, der den Quellcode in Objektdateien übersetzt und das Programm erzeugt.
<P>Normalerweise würden Sie so starten:
Öffnen Sie einen Editor Ihrer Wahl - benutzen Sie keine Textverarbeitung. Geben Sie etwa dieses ein, um den Quellcode Ihres ersten
Programmes zu schreiben:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
#include &lt;iostream.h>

int main(){

cout &lt;&lt; "Hello World" &lt;&lt; endl;

}
</PRE>
</CODE></BLOCKQUOTE>
<P>Nun, alles, was das Programm tun wird, ist den String "Hello World" auf Ihrer Standardausgabe auszugeben. Aber dies ist nur der
Quellcode für ein zu erstellendes Programm, nicht das Programm selbst. Daher benötigen Sie einen Compiler, in diesem Fall ein
C++-Compiler wie etwa g++. Dann können Sie den Quellcode als Datei speichern, sagen wir als myprogram.cpp und den Compiler mit dem
Dateinamen aufrufen (auf einer Konsole):
<P>
<BLOCKQUOTE><CODE>
<PRE>
g++ -o myprogram myprogram.cpp
</PRE>
</CODE></BLOCKQUOTE>
<P>Danach können wir unser Programm starten- geben Sie einfach <CODE>myprogram</CODE> auf der Konsole ein, und das Programm gibt den String aus
und beendet sich.
<P>
<H3><A NAME="Make"></A> <A NAME="ss3.2">3.2 Make und Makefiles</A>
</H3>

<P>Ich habe jetzt alles, was ich brauche: einen Editor, einen Compiler und ich kann mein eigenes C++ Programm ausführen. Aber es ist nicht
ganz so einfach. Was passiert, wenn Sie mehr als eine Quellcodedatei haben? Und, müssen Sie dann die Quellen immer wieder übersetzen,
wenn Sie nur eine Datei geändert haben? Der Übersetzungsvorgang wird immer komplizierter und zeitraubender, weil Sie alle Kommandos
und Optionen selbst eintippen müssen. Deshalb können Sie sich ein sogenanntes "Makefile" schreiben. Man könnte es genausogut anders
nennen, außer dem Namen des Programms, das zu erstellen ist. Dann sollten Sie das Werkzeug <CODE>make</CODE> oder <CODE>gmake</CODE> installiert haben,
oder ein anderes Werkzeug, das den Übersetzungsvorgang überwacht. Fügen Sie alle Compileranweisungen in der speziellen
Erstellungssyntax in das Makefile ein und speichern Sie es; danach brauchen Sie nur noch <CODE>make</CODE> oder <CODE>gmake</CODE> auf der Konsole in
dem Verzeichnis einzugeben, wo sich das Makefile befindet; make übernimmt dann und bringt den Compiler dazu Ihr Programm zu erzeugen.
Das Make-Werkzeug hat noch viele weitere Vorteile und kann zu vielen Zwecken verwendet werden. Um eine Übersicht zu bekommen, öffnen
Sie eine Konsole und geben Sie ein:
<P><CODE>man make</CODE>
<P>oder suchen Sie nach "GNU Make" in der KDE-Hilfe unter "System GNU Info contents".
<P>Dies erklärt Ihnen, warum ein Entwickler das Make-Werkzeug benötigt, um den Übersetzungsvorgang seiner Applikation zu vereinfachen. Nun,
das Schreiben der Makefiles ist jetzt nicht nur Handarbeit, Sie müssen sich auch noch in die Syntax und die Optionen hineinarbeiten.
Aber hier ist die gute Nachricht über KDevelop und das Make-Werkzeug: Sie müssen nur das Make-Kommando im 
<A HREF="index-14.html#KDevelop Setup">KDevelop Setup</A>  Dialog setzen und Sie sind soweit. Alle Projekte, die von KDevelop erzeugt werden, benutzen das
Make-Kommando um die Zielapplikation zu erstellen, und Sie müssen nichts eingeben. Klicken Sie einfach auf den Make-Knopf in der
Werkzeugleiste oder wählen Sie die gewünschte Funktion aus dem "Erstellen" Menü.
<P>Die Werkzeugleiste und das "Erstellen"-Menü bieten die meist benutzten Funktionen, um make die Arbeit erledigen zu lassen:
<P>
<UL>
<LI> Datei compilieren: ist nur aktiv, wenn Sie an einer Quellcode-Datei arbeiten. Diese Funktion ruft make mit dem korrekten
Kommando auf, nur die aktuelle Quelldatei zu übersetzen.</LI>
<LI> Erstellen: ruft make auf und erzeugt das Zielobjekt (die Applikation)</LI>
<LI> Alles neu erstellen: löscht alle schon übersetzten Dateien und erstellt das Projekt neu</LI>
<LI> Säubern/alles neu erstellen: löscht alle übersetzten Dateien inklusive der Konfigurationsdateien des Projekts und erstellt alles
neu</LI>
<LI> Stoppen: beendet den aktuellen Prozeß</LI>
<LI> Ausführen: erstellt die Zieldatei und führt das Programm aus</LI>
<LI> Mit Argumenten ausführen: erstellt die Zieldatei und gibt Ihnen die Möglichkeit, dem Programm vor seiner Ausführung
Kommandozeilenoptionen zu übergeben.</LI>
<LI> Debuggen: erstellt die Zieldatei und startet KDbg mit dem Programm, um es zu debuggen</LI>
</UL>
<P>Aber dies ist nicht das einzige, wo KDevelop mit make zusammenarbeitet- bei KDE Applikationen sind einige Dinge speziell auf die
Unterstützung des Entwicklers abgestimmt wie die Erzeugung der Messages-Datei für die Internationalisierung Ihres Projekts. Diese
Funktionen sind ebenfalls sorgfältig integriert, so daß Sie sich darüber nicht mehr den Kopf zerbrechen müssen.
<P>Bis jetzt wissen Sie schon einiges über Quelldateien, den Compiler und warum make benötigt wird. Im nächsten Abschnitt werden wir
besprechen, warum Projekte, die mit KDevelop erstellt wurden, automatisch durch Verwendung eines <CODE>configure</CODE>-Scripts auf den meisten
Unix-Plattformen übersetzt werden können.
<P>
<H3><A NAME="Configure"></A> <A NAME="ss3.3">3.3 Configure</A>
</H3>

<P>Der Titel dieses Abschnitts- Configure, bedeutend soviel wie Konfiguriere - läßt Sie wahrscheinlich fragen: Konfiguriere ? Was muß
konfiguriert werden ? Oder wer ?
<P>Nun, gehen wir davon aus, daß Sie ein Programm geschrieben haben inklusive einem Makefile. Dann wollen Sie es verbreiten, aber die
compilierte Binärdatei läuft nur auf Ihrem System und auf solchen, die mit Ihrem kompatibel sind. Um andere Plattformen zu unterstützen
wie die verschiedenen Unix-Systeme oder Maschinen wie Alpha's oder RISC's müssen Sie ihr Programm neu übersetzen. Der einfachste Weg
wäre, das Quellpaket auf die Zielmaschine zu kopieren und <CODE>make</CODE> nochmals laufen zu lassen. Aber was wäre, wenn die Zielmaschine
einen anderen Compiler benutzt oder in anderer Weise ein Problem erzeugt, die ein Erstellen des Programms verhindert ? Nicht zu
erwähnen die schwierigeren Dinge wie der Installationspfad für Ihr Programm und Dokumentation- z.B. kann KDE auf einer Maschine
unter <CODE></CODE>opt/kde/ installiert sein, auf einer anderen aber unter <CODE>usr</CODE>local/kde/. In diesem Fall müßten Sie das Makefile immer
bearbeiten, um eine korrekte Übersetzung und Installation Ihres Produkts sicherzustellen.
<P>Glücklicherweise haben die GNU-Werkzeuge noch mehr zu bieten als das mächtige <CODE>make</CODE>- die allgemein genutzten Pakete automake und
autoconf. Es klingt gut, etwas mit "auto"- es scheint als ob etwas beim Applikations-Design einfach und schnell gemacht werden kann,
was auch genau den Punkt trifft.
<P>Der Zweck von <CODE>automake</CODE> ist generell, die sogenannten <CODE>Makefile.in</CODE>'s aus der Datei <CODE>Makefile.am</CODE> zu erstellen, die Sie für
Ihr Projekt anstatt einer "richtigen" Makefile schreiben müssen. Diese Makefile.am besteht aus Makros, die leicht zu verstehen
ist Komplexität reduziert, die make anbietet, so daß eine Makefile.am fehlerloser und schneller geschrieben werden kann als das letztliche
Makefile.
<P>Aber wer erzeugt mir dann letztlich mein Makefile ?  Nun, hier kommt autoconf. Autoconf benötigt verschiedene Makrodateien für das
Projekt. Diese sind die Makefile.in's, die automake erzeugt hat und eine Datei namesn <CODE>configure.in</CODE>, die auch aus Makros besteht.
Hierbei beinhalten die Makefile.am und .in's die Makros die dafür verantwortlich sind, wie das Ziel erstellt wird in Bezug auf die
Quellen, die übersetzt werden müssen, welche Dateien zum Paket gehören und welchen Namen die letzliche Binärdatei oder Bibliothek nach
einem Erstellungsvorgang hat. <CODE>configure.in</CODE> andererseits beinhaltet die Makros, nach denen das letztliche configure-Skript das System
prüft, auf denen configure ausgeführt wird. Dies können z.B. das Compiler-Kommando, benötigte Bibliotheken zu denen die letzliche
Binärdatei gelinkt wird und include-Dateien, die das Projekt benötigt, sein.
<P>Wenn Sie z.B. eine KDE Applikation schreiben und nach der Fertigstellung Ihr Programm Benutzern zur Verfügung stellen möchten, muß
jeder Benutzer die Binärdatei selbst compilieren. Dann würden Sie eine <CODE>configure.in</CODE> Datei, die die Makros für eine KDE-kompatible
Applikation enthält. Diese Makros werden dann expandiert zu einer Systemprüfung, ob die Qt-Bibliothek installiert ist, dem Pfad der
Qt-Headerdateien, den KDE Bibliotheken und Headern etc.
<P>
<P><B>Zusammenfassung:</B> Um eine GNU-gemäße Applikation zu erstellen, die auf verschiedene Unix-Betriebssysteme und andere Maschinen
als Ihre eigene portabel sein soll, müssen Sie folgendes ausführen:
<P>
<OL>
<LI> die Quellen Ihres Projekts schreiben</LI>
<LI> eine Makefile.am für jedes Unterverzeichnis erstellen, inklusive dem Hauptverzeichnis Ihres Projekts</LI>
<LI> eine configure.in Datei im Hauptverzeichnis erstellen, das die Makros für die Systemanforderungen enthält</LI>
<LI> automake aufrufen</LI>
<LI> autoconf aufrufen</LI>
</OL>
<P>Dann ist die Hauptarbeit getan. Automake erzeugt die Makefile.in's, autoconf läuft über die <CODE>configure.in</CODE> und erzeugt
das ausführbare Shellscript <CODE>configure</CODE>. Alles, was Sie dann zu tun haben, ist die Ausführung mit <CODE>./configure</CODE>, und das
Skript wird die Prüfungen durchführen. Schließlich werden die Makefiles erzeugt, die die Ausführung von make (oder gmake) erlauben, um
das Projekt zu erstellen.
<P>Dies alles scheint ein bißchen viel zu sein, nur um eine kleine Applikation zu schreiben und auch viel zu lernen, speziell die
korrekten Makros. Aber allein der Umstand, daß Sie damit einen Kompiliervorgang auf fast allen Unix-Systemen erreichen, macht die
Arbeit früher oder später wett. Schließlich müssen Sie diese Arbeit auch nur einmal für das Projekt machen und im Fall, daß Ihre
Projektdateien anwachsen, brauchen Sie ja nur die Dateinamen den Makros hinzufügen.
<P>Nun, inwiefern unterstützt KDevelop diese Art der Applikationserstellung und wie kompliziert wird es für den Programmierer?
Die gute Nachricht für Sie ist: Sie brauchen noch nicht eimal etwas über Makros und Skripte zu wissen. Alle Details sind hinter einer
einfach zu bedienenden graphischen Benutzeroberfläche versteckt, die die Arbeit für Sie übernimmt. Eine Applikation wird mit den
GNU-Tools deshalb auf sehr benutzerfreundliche Art erstellt:
<P>Erzeugen Sie Ihre Applikation einfach mit dem KAppWizard nach Wahl der Bedürfnisse Ihrer Applikation- es mag ein reines C++
Terminalprogramm sein oder eine Art GUI Programm, das die Qt oder die Qt/KDE Bibliothek benutzt. Die ganze Arbeit wird
für Sie erledigt und Ihr Projekt enthält schon die Makefiles, die durch eine automatische Ausführung der GNU-Tools und des
configure-Skripts erstellt wurden.
<P>Das wäre es schon- Sie brauchen nur die Quellen Ihres Projekts zu erweitern, sei es durch Hinzufügen von Klassen, Dialogen,
Übersetzungen oder Dokumentation, was auch vollständig automatisiert abläuft. Konzentrieren Sie sich einfach auf die wirkliche Arbeit
eines Entwicklers, nämlich Ihrer Applikation Funktionalität zu verleihen. In den meisten Fällen werden Sie wahrscheinlich nie mit
Makefiles in Berührung kommen, wenn Sie KDevelop benutzen.
<P>
<H3><A NAME="Debuggen"></A> <A NAME="ss3.4">3.4 Debuggen</A>
</H3>

<P>Der folgende Abschnitt betrachtet einen Terminus, der unter Entwicklern weit verbreitet ist: Debuggen. Das bedeutet, daß, obwohl Ihr
Compiler die letzliche Applikation erzeugt, das Programm aber nicht läuft oder während der Ausführung abstürzt wegen eines sogenannten
"Bugs" (Käfer) im Code. Ein Programmfehler, der mit dem Namen dieser Insekten beschrieben wird, stammt aus der Geschichte des
Computers; einer der ersten Fehler, die eine Maschine zum Absturz brachte, war keine offensichtliche Fehlfunktion- Käfer waren in den
Computer eingedrungen und waren dafür verantwortlich. Daher beschreibt man einen Fehler, der auf den ersten Blick nicht offensichtlich
ist, als einen "Bug", daher bedeutet "Debuggen", die Käfer zu entfernen, wo sie nicht hingehören. Nun, Sie brauchen sie nicht wirklich
zu jagen; vorausgesetzt daß die heutigen Computer konzipiert sind, diese durch einen Schutz fernzuhalten. Sie müssen innerhalb des
Codes gefunden werden, wenn sie die Ausführung eines Programms mit der Nachricht "Segmentation fault" (Speicherverletzung) beenden.
GNU bietet dazu ein weiteres Werkzeug, <CODE>gdb</CODE>, den GNU Debugger. Dieses Terminalprogramm erlaubt es, die internen Werte einer
Applikation und die Ausführung durch setzen von Haltepunkten im Code zu beobachten. Gdb stoppt die Ausführung jedes mal, wenn das
Programm an einen Haltepunkt kommt. Aber wie die meisten Werkzeuge wird auch der Debugger von einem anderen Programm gesteuert, das ein
Frontend dazu bietet und es erlaubt, die Werte einfach zu beobachten und Haltepunkte im Code zu setzen.
<P>Zu diesem Zweck wird die Applikation Ihres Projekts standardmäßig mit der Compileroption zum Debuggen erzeugt und speichert daher
zusätzliche Daten in der Binärdatei, um die Werte und Zeilen im Code zu lokalisieren. Als Frontend zu gdb benutzt KDevelop das Programm
KDbg, den KDebugger. Um Ihr Programm zu debuggen, müssen Sie nur "Debuggen" im "Erstellen" Menü auswählen oder den entsprechenden
Werkzeugleistenknopf betätigen, der durch ein Rad mit Brille dargestellt wird und signalisiert, das Sie die Ausführung beobachten
wollen.
<P>KDevelop öffnet dann das Werkzeuge-Fenster und startet Ihr Programm mit KDbg. Die KDbg Oberfläche erscheint dann innerhalb des
Werkzeuge-Fensters und erlaubt die Benutzung genauso als ob Sie den Debugger außerhalb von KDevelop gestartet hätten.
<P>Ganz allgemein zeigen die obigen Schritte, das ein Entwickler zum Schreiben seines eigenen Programms verschiedene Stufen durchlaufen
muß, um ein Projekt zu beginnen. Auch erklärt dies, welchen Teil KDevelop dabei übernimmt und wie die Entwicklungsumgebung die Idee eines einfachen Wegs
zur Unix-Programmierung unterstützt. Um weitere Informationen über die GNU Tools zu erhalten, sollten Sie die zugehörige Dokumentation
lesen, die Sie allgemein über das <CODE>man</CODE> Kommando oder über "System GNU Info contents" in der KDE Hilfe nachschlagen können.
<P>
<P>
<P ALIGN="RIGHT">

<A HREF="index-4.html">Weiter</A>
 <A HREF="index-2.html">Zurück</A>
 <A HREF="index.html#toc3">Inhaltsverzeichnis</A>
</P>
<CENTER>
<HR WIDTH="100%" SIZE=3 ALIGN=CENTER NOSHADE>
</CENTER>    
</FONT>

 
</BODY>
</HTML>
